{"version":3,"sources":["../../src/model/apostille.js"],"names":["hashing","name","signedVersion","version","hashFileData","data","isPrivate","checksum","CryptoJS","MD5","SHA1","SHA256","SHA3","outputLength","create","common","fileName","fileContent","tags","isMultisig","network","dedicatedAccount","apostilleHash","kp","KeyPair","Helpers","fixPrivateKey","privateKey","generateAccount","hash","substring","dataHash","sign","toString","address","Sinks","apostille","toUpperCase","replace","transaction","modelObjects","transactionEntity","Transactions","prepare","verify","apostilleTransaction","type","otherTrans","message","payload","hashingByte","fileHash","retrieveHash","isSigned","verifySignature","signer","hashingVersionBytes","enc","Hex","array","Object","keys","i","length","signedFilename","dedicatedAccountPrivateKey","dedicatedAccountKeyPair","Address","toAddress","publicKey","module","exports"],"mappings":"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","file":"apostille.js","sourcesContent":["import CryptoJS from 'crypto-js';\nimport Helpers from '../utils/helpers';\nimport Convert from '../utils/convert';\nimport KeyPair from '../crypto/keyPair';\nimport Address from '../model/address';\nimport Sinks from '../model/sinks';\nimport modelObjects from '../model/objects';\nimport Transactions from '../model/transactions';\n\n/**\n * Apostille hashing methods with version bytes\n *\n * @type {object}\n */\nconst hashing = {\n\t\"MD5\": {\n\t    name: \"MD5\",\n\t    signedVersion: \"81\",\n\t    version: \"01\"\n\t},\n\t\"SHA1\": {\n\t    name: \"SHA1\",\n\t    signedVersion: \"82\",\n\t    version: \"02\"\n\t},\n\t\"SHA256\" : {\n\t    name: \"SHA256\",\n\t    signedVersion: \"83\",\n\t    version: \"03\"\n\t},\n\t\"SHA3-256\": {\n\t    name: \"SHA3-256\",\n\t    signedVersion: \"88\",\n\t    version: \"08\"\n\t},\n\t\"SHA3-512\": {\n\t    name: \"SHA3-512\",\n\t    signedVersion: \"89\",\n\t    version: \"09\"\n\t}\n}\n\n/**\n * Hash the file content depending of hashing\n *\n * @param {wordArray} data - File content\n * @param {object} hashing - The chosen hashing object\n * @param {boolean} isPrivate - True if apostille is private, false otherwise\n *\n * @return {string} - The file hash with checksum\n */\nlet hashFileData = function(data, hashing, isPrivate) {\n    // Full checksum is 0xFE + 0x4E + 0x54 + 0x59 + hashing version byte\n    let checksum;\n    // Append byte to checksum\n    if (isPrivate) {\n        checksum = \"fe4e5459\" + hashing.signedVersion;\n    } else {\n        checksum = \"fe4e5459\" + hashing.version;\n    }\n    // Build the apostille hash\n    if (hashing.name === \"MD5\") {\n        return checksum + CryptoJS.MD5(data);\n    } else if (hashing.name === \"SHA1\") {\n        return checksum + CryptoJS.SHA1(data);\n    } else if (hashing.name === \"SHA256\") {\n        return checksum + CryptoJS.SHA256(data);\n    } else if (hashing.name === \"SHA3-256\") {\n        return checksum + CryptoJS.SHA3(data, {\n            outputLength: 256\n        });\n    } else {\n        return checksum + CryptoJS.SHA3(data, {\n            outputLength: 512\n        });\n    }\n};\n\n/**\n * Create an apostille object\n *\n * @param {object} common - A common object\n * @param {string} fileName - The file name (with extension)\n * @param {wordArray} fileContent - The file content\n * @param {string} tags - The apostille tags\n * @param {object} hashing - An hashing object\n * @param {boolean} isMultisig - True if transaction is multisig, false otherwise\n * @param {boolean} isPrivate - True if apostille is private / transferable / updateable, false if public\n * @param {number} network - A network id\n *\n * @return {object} - An apostille object containing apostille data and the prepared transaction ready to be sent\n */\nlet create = function(common, fileName, fileContent, tags, hashing, isMultisig, isPrivate, network) {\n\tlet dedicatedAccount = {};\n\tlet apostilleHash;\n\t//\n\tif (isPrivate) {\n        // Create user keypair\n        let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));\n        // Create the dedicated account\n        dedicatedAccount = generateAccount(common, fileName, network);\n        // Create hash from file content and selected hashing\n        let hash = hashFileData(fileContent, hashing, isPrivate);\n        // Get checksum\n        let checksum = hash.substring(0, 10);\n        // Get hash without checksum\n        let dataHash = hash.substring(10);\n        // Set checksum + signed hash as message\n        apostilleHash = checksum + kp.sign(dataHash).toString();\n    } else {\n        // Use sink account\n        dedicatedAccount.address = Sinks.apostille[network].toUpperCase().replace(/-/g, '');\n        // Set recipient private key\n        dedicatedAccount.privateKey = \"None (public sink)\";\n        // No signing we just put the hash in message\n        apostilleHash = hashFileData(fileContent, hashing, isPrivate);\n\t}\n\n\t// Create transfer transaction object\n\tlet transaction = modelObjects.create(\"transferTransaction\")(dedicatedAccount.address, 0, apostilleHash);\n\t// Prepare the transfer transaction object\n\tlet transactionEntity = Transactions.prepare(\"transferTransaction\")(common, transaction, network);\n\n\treturn {\n\t\t\"data\": {\n\t\t\t\"file\": {\n\t\t\t\t\"name\": fileName,\n\t\t\t\t\"hash\": apostilleHash.substring(10),\n\t\t\t\t\"content\": fileContent\n\t\t\t},\n\t\t\t\"hash\": apostilleHash,\n\t\t\t\"checksum\": apostilleHash.substring(0, 10),\n\t\t\t\"dedicatedAccount\": {\n\t\t\t\t\"address\": dedicatedAccount.address,\n\t\t\t\t\"privateKey\": dedicatedAccount.privateKey\n\t\t\t},\n\t\t\t\"tags\": tags\n\t\t},\n\t\t\"transaction\": transactionEntity\n\t}\n}\n\n/**\n * Verify an apostille\n *\n * @param {wordArray} fileContent - The file content\n * @param {object} apostilleTransaction - The transaction object for the apostille\n *\n * @return {boolean} - True if valid, false otherwise\n */\nlet verify = function(fileContent, apostilleTransaction) {\n    let apostilleHash;\n    if(apostilleTransaction.type === 4100) {\n        apostilleHash = apostilleTransaction.otherTrans.message.payload;\n    } else {\n        apostilleHash = apostilleTransaction.message.payload;\n    }\n\t// Get the checksum\n\tlet checksum = apostilleHash.substring(0, 10);\n\t// Get the hashing byte\n\tlet hashingByte = checksum.substring(8);\n\t// Retrieve the hashing method using the checksum in message and hash the file accordingly\n\tlet fileHash = retrieveHash(apostilleHash, fileContent);\n\t// Check if apostille is signed\n\tif(isSigned(hashingByte)) {\n\t\t// Verify signature\n\t\treturn KeyPair.verifySignature(apostilleTransaction.signer, fileHash, apostilleHash.substring(10));\n\t} else {\n\t\t// Check if hashed file match hash in transaction (without checksum)\n\t\treturn fileHash === apostilleHash.substring(10);\n\t}\n}\n\n\n/**\n * Hash a file according to version byte in checksum\n *\n * @param {string} apostilleHash - The hash contained in the apostille transaction\n * @param {wordArray} fileContent - The file content\n *\n * @return {string} - The file content hashed with correct hashing method\n */\nlet retrieveHash = function(apostilleHash, fileContent) {\n\t// Get checksum\n\tlet checksum = apostilleHash.substring(0, 10)\n    // Get the version byte\n    let hashingVersionBytes = checksum.substring(8);\n    // Hash depending of version byte\n    if (hashingVersionBytes === \"01\" || hashingVersionBytes === \"81\") {\n        return CryptoJS.MD5(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"02\" || hashingVersionBytes === \"82\") {\n        return CryptoJS.SHA1(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"03\" || hashingVersionBytes === \"83\") {\n\t\treturn CryptoJS.SHA256(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"08\" || hashingVersionBytes === \"88\") {\n        return CryptoJS.SHA3(fileContent, { outputLength: 256 }).toString(CryptoJS.enc.Hex);\n    } else {\n        return CryptoJS.SHA3(fileContent, { outputLength: 512 }).toString(CryptoJS.enc.Hex);\n    }\n}\n\n/**\n * Check if an apostille is signed\n *\n * @param {string} hashingByte - An hashing version byte\n *\n * @return {boolean} - True if signed, false otherwise\n */\nlet isSigned = function(hashingByte) {\n\tlet array = Object.keys(hashing);\n    for (let i = 0; array.length > i; i++) {\n        if (hashing[array[i]].signedVersion === hashingByte) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Generate the dedicated account for a file. It will always generate the same private key for a given file name and private key\n *\n * @param {object} common - A common object\n * @param {string} fileName - The file name (with extension)\n * @param {number} network - A network id\n *\n * @return {object} - An object containing address and private key of the dedicated account\n */\nlet generateAccount = function(common, fileName, network) {\n\t// Create user keypair\n\tlet kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));\n    // Create recipient account from signed sha256 hash of new filename\n    let signedFilename = kp.sign(CryptoJS.SHA256(fileName).toString(CryptoJS.enc.Hex)).toString();\n    // Truncate signed file name to get a 32 bytes private key\n    let dedicatedAccountPrivateKey = Helpers.fixPrivateKey(signedFilename);\n    // Create dedicated account key pair\n    let dedicatedAccountKeyPair = KeyPair.create(dedicatedAccountPrivateKey);\n    return {\n    \t\"address\":  Address.toAddress(dedicatedAccountKeyPair.publicKey.toString(), network),\n    \t\"privateKey\": dedicatedAccountPrivateKey\n    }\n}\n\nmodule.exports = {\n    create,\n    generateAccount,\n    hashing,\n    verify\n}\n"]}